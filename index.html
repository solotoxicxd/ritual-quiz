<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ritual Quiz Challenge</title>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary-gradient: linear-gradient(135deg, #19d184 0%, #19d184 100%);
            --secondary-gradient: linear-gradient(135deg, #000000 0%, #000000 100%);
            --accent-gradient: linear-gradient(135deg, #19d184 0%, #19d184 100%);
            --glass-bg: rgba(255, 255, 255, 0.1);
            --glass-border: rgba(255, 255, 255, 0.2);
            --text-primary: #ffffff;
            --text-secondary: rgba(255, 255, 255, 0.8);
            --success-color: #10b981;
            --danger-color: #ef4444;
            --warning-color: #f59e0b;
        }
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Poppins', sans-serif;
            background: #000000;
            background-attachment: fixed;
            min-height: 100vh;
            color: var(--text-primary);
            overflow-x: hidden;
        }
        .glass-container {
            background: var(--glass-bg);
            backdrop-filter: blur(20px);
            border: 1px solid var(--glass-border);
            border-radius: 20px;
            padding: 2rem;
            animation: slideIn 0.8s ease-out;
        }
        @keyframes slideIn { from {opacity:0; transform:translateY(30px) scale(.95);} to {opacity:1; transform:translateY(0) scale(1);} }
        .screen { display:none; min-height:100vh; padding:2rem; align-items:center; justify-content:center; }
        .screen.active { display:flex; }
        .welcome-content { text-align:center; max-width:500px; width:100%; }
        .logo {
            font-size:3rem; font-weight:700;
            background:var(--accent-gradient);
            -webkit-background-clip:text; background-clip:text;
            -webkit-text-fill-color:transparent;
            margin-bottom:1rem; animation:glow 2s ease-in-out infinite alternate;
        }
        .subtitle { font-size:1.2rem; color:var(--text-secondary); margin-bottom:2rem; font-weight:300; }
        .input-group { margin-bottom:2rem; }
        .glass-input {
            width:100%; padding:1rem 1.5rem; background:var(--glass-bg);
            border:1px solid var(--glass-border); border-radius:15px;
            color:var(--text-primary); font-size:1.1rem; transition:.3s;
        }
        .glass-input:focus { border-color:#19d184; transform:scale(1.02); }
        .btn {
            padding:1rem 2rem; border:none; border-radius:15px;
            font-size:1.1rem; font-weight:600; cursor:pointer;
            transition:.3s; position:relative; overflow:hidden;
        }
        .btn::before {
            content:''; position:absolute; top:0; left:-100%; width:100%; height:100%;
            background:linear-gradient(90deg, transparent, rgba(255,255,255,.2), transparent);
            transition:left .5s;
        }
        .btn:hover::before { left:100%; }
        .btn-primary { background:var(--primary-gradient); color:var(--text-primary); }
        .btn-secondary { background:var(--glass-bg); border:1px solid var(--glass-border); color:var(--text-primary); }
        .btn-share { background:linear-gradient(135deg,#19d184 0%,#19d184 100%); color:white; margin:.5rem; }
        .rules-list { list-style:none; margin-bottom:2rem; text-align:center; }
        .rules-list li { padding:1rem 0; border-bottom:1px solid rgba(255,255,255,.1); font-size:1.1rem; }
        .quiz-header { display:flex; justify-content:space-between; align-items:center; margin-bottom:2rem; gap:1rem; flex-wrap:wrap; }
        .progress-container { flex:1; margin:0 1rem; min-width:200px; }
        .progress-bar { height:8px; background:rgba(255,255,255,.2); border-radius:10px; overflow:hidden; }
        .progress-fill { height:100%; background:var(--accent-gradient); transition:width .3s; border-radius:10px; }
        .progress-text { text-align:center; margin-top:.5rem; color:var(--text-secondary); }
        .timer { display:flex; align-items:center; justify-content:center; width:80px; height:80px;
            border-radius:50%; background:var(--glass-bg); border:3px solid var(--success-color);
            font-size:1.6rem; font-weight:700; transition:.3s;
        }
        .timer.warning { border-color:var(--warning-color); color:var(--warning-color); }
        .timer.danger { border-color:var(--danger-color); color:var(--danger-color); }
        .question-text { font-size:1.4rem; margin-bottom:2rem; }
        .options-container { display:grid; gap:1rem; grid-template-columns:repeat(auto-fit,minmax(250px,1fr)); }
        .option {
            background:var(--glass-bg); border:2px solid var(--glass-border);
            border-radius:15px; padding:1.2rem; cursor:pointer; transition:.3s;
        }
        .option:hover { transform:translateY(-5px) scale(1.02); border-color:rgba(0,163,122,.6); }
        .option.correct { background:rgba(16,185,129,.3); border-color:var(--success-color); }
        .option.incorrect { background:rgba(239,68,68,.3); border-color:var(--danger-color); }
        .results-content { text-align:center; max-width:500px; }
        .score-display {
            font-size:4rem; font-weight:700; background:var(--accent-gradient);
            -webkit-background-clip:text; background-clip:text; -webkit-text-fill-color:transparent;
        }
        .action-buttons { display:flex; gap:1rem; justify-content:center; flex-wrap:wrap; margin-top:2rem; }
        .footer { position:fixed; bottom:1rem; right:1rem; color:var(--text-secondary); font-size:.9rem; }
    </style>
</head>
<body>

<!-- WELCOME -->
<div id="welcomeScreen" class="screen active">
    <div class="glass-container welcome-content">
        <h1 class="logo">Ritual Quiz</h1>
        <p class="subtitle">Challenge Your Knowledge</p>
        <div class="input-group">
            <input type="text" id="usernameInput" class="glass-input" placeholder="Enter your name" maxlength="20">
        </div>
        <button class="btn btn-primary" onclick="showRules()">Start Challenge</button>
    </div>
</div>

<!-- RULES -->
<div id="rulesScreen" class="screen">
    <div class="glass-container rules-content">
        <h2 style="text-align:center; margin-bottom:2rem;">Quiz Rules</h2>
        <ul class="rules-list">
            <li>10 challenging questions</li>
            <li>4 multiple choice answers each</li>
            <li>15 seconds per question</li>
            <li>Auto-advance when timer expires</li>
            <li>No going back</li>
            <li>Score revealed at the end</li>
        </ul>
        <div style="text-align:center;">
            <button class="btn btn-secondary" onclick="showWelcome()">Back</button>
            <button class="btn btn-primary" onclick="startQuiz()">Let's Begin!</button>
        </div>
    </div>
</div>

<!-- QUIZ -->
<div id="quizScreen" class="screen">
    <div class="glass-container" style="max-width:800px; width:100%;">
        <div class="quiz-header">
            <div style="font-weight:600;">Score: <span id="currentScore">0</span></div>
            <div class="progress-container">
                <div class="progress-bar">
                    <div class="progress-fill" id="progressFill"></div>
                </div>
                <div class="progress-text" id="progressText">Question 1 of 10</div>
            </div>
            <!-- FIXED TIMER -->
            <div class="timer" id="timer">15</div>
        </div>
        <div class="question-container">
            <h3 class="question-text" id="questionText"></h3>
            <div class="options-container" id="optionsContainer"></div>
        </div>
    </div>
</div>

<!-- RESULTS -->
<div id="resultsScreen" class="screen">
    <div class="glass-container results-content">
        <h2>Quiz Complete!</h2>
        <div class="score-display" id="finalScore">0/10</div>
        <p class="score-message" id="scoreMessage"></p>
        <div class="action-buttons">
            <button class="btn btn-share" onclick="shareToX()">Share on X</button>
            <button class="btn btn-primary" onclick="restartQuiz()">Try Again</button>
        </div>
    </div>
</div>

<div class="footer">Made by <a href="#">Bytrizz</a></div>

<script>
    const quizData = [
        { question:"Within Ritual’s Symphony protocol, which mechanism ensures validator consensus on heterogeneous off-chain computations while minimizing redundant execution?",
          options:[
            "Weighted-majority gossip rounds determining probabilistic correctness.",
            "Executor-provided succinct proofs or attested TEE outputs verified by deterministically assigned proof shards.",
            "Re-execution of the computation by every validator node for cross-verification.",
            "Asynchronous batching of inference results through optimistic settlement."
          ], correct:1 },
        { question:"When Ritual’s Infernet orchestrates inference across distributed AI executors, what underlying property guarantees composability with external L1/L2s?",
          options:[
            "Infernet maintains an off-chain indexer layer for every external chain.",
            "Cross-domain compute proofs are wrapped in canonical message envelopes verified by Ritual Chain’s Symphony consensus.",
            "External chains directly read cached responses from Ritual node mempools.",
            "Ritual mirrors its state roots to all supported chains via static RPC bridging."
          ], correct:3 },
        { question:"Which operational risk arises from Resonance’s compute fee market during load spikes, and how is it algorithmically mitigated?",
          options:[
            "Task starvation of low-fee requests, mitigated through dynamic priority decay and time-weighted bids.",
            "Overpricing of high-latency models, mitigated via static gas caps per workload type.",
            "Executor monopoly formation, mitigated only by node whitelisting.",
            "Invalid bid propagation, mitigated through human governance arbitration."
          ], correct:0 },
        { question:"In Ritual’s architecture, what prevents a malicious TEE executor from replaying signed outputs as new valid inferences?",
          options:[
            "TEE sessions are tied to ephemeral attestation keys and unique execution nonces embedded in proof metadata.",
            "Infernet timestamps every result in block headers to prevent temporal reuse.",
            "TEE proofs are manually invalidated by governance after each task cycle.",
            "Replay resistance is provided only by the executor’s public reputation score."
          ], correct:0 },
        { question:"What subtle advantage does Ritual’s proof-system agnosticism provide for AI verifiability, beyond flexibility?",
          options:[
            "Allows zero-cost migration between ZK systems without recompilation.",
            "Permits hybrid proof pipelines — e.g., ZKML for inference correctness, TEE attestation for data secrecy — optimizing trust boundaries per workload.",
            "Eliminates need for deterministic model weights on-chain.",
            "Lets developers outsource proof verification entirely to other chains."
          ], correct:1 },
        { question:"Within Symphony’s dual-proof sharding, what ensures that no single shard can bias final verification?",
          options:[
            "Cross-shard recombination with quorum-weighted cross-signatures validated by meta-committees.",
            "Static shard assignment so validators remain consistent between epochs.",
            "Proof rotation every epoch determined by static randomness seeds.",
            "Validator honesty assumption without cryptographic enforcement."
          ], correct:0 },
        { question:"How does Ritual encode immutable lineage for enshrined models to maintain auditability even if contributors vanish?",
          options:[
            "By replicating the contributor list through IPFS mirrors.",
            "By embedding signed contribution manifests directly within model metadata hashes, permanently anchored in Ritual Chain state.",
            "Through optional contributor acknowledgments stored in governance logs.",
            "Using off-chain attestations submitted to Infernet indexers."
          ], correct:1 },
        { question:"In scheduling autonomous agents, what structural safeguard prevents infinite recursive invocation or denial-of-service loops?",
          options:[
            "Recursive agent limits enforced by off-chain keepers.",
            "Dynamic gas throttling based on agent priority queue density.",
            "Deterministic call-graph bounding and execution context sealing at the protocol level.",
            "Randomized epoch resets that clear pending agent tasks."
          ], correct:2 },
        { question:"What cryptoeconomic design prevents centralized control of inference-heavy nodes within the Resonance market?",
          options:[
            "Linear stake-weighted selection of executors.",
            "Periodic identity resets using Proof-of-Hardware commitments.",
            "Sybil-resistant bonding curves that increase marginal stake cost for repeated executor selection.",
            "Time-based decay of delegation reputation tied to compute variance."
          ], correct:2 },
        { question:"Which layer in Ritual’s architecture mediates between off-chain heterogeneous execution and on-chain finality for verifiable results?",
          options:[
            "The Proof Relay Layer integrating Infernet’s output commitments into Symphony consensus.",
            "The RPC routing layer handling direct node responses.",
            "The Resonance fee aggregator layer optimizing price discovery.",
            "The Governance pipeline filtering invalid inference traces."
          ], correct:0 }
    ];

    let currentQuestion = 0, score = 0, timer = 15, timerInterval, username = "", isAnswered = false;

    function showScreen(id){
        document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
        document.getElementById(id).classList.add('active');
    }
    function showWelcome(){ showScreen('welcomeScreen'); }
    function showRules(){
        username = document.getElementById('usernameInput').value.trim();
        if(!username) return alert("Please enter your name!");
        showScreen('rulesScreen');
    }
    function startQuiz(){
        currentQuestion = 0; score = 0; showScreen('quizScreen');
        displayQuestion(); startTimer();
    }
    function restartQuiz(){
        clearInterval(timerInterval);
        showScreen('welcomeScreen');
    }

    function displayQuestion(){
        const q = quizData[currentQuestion];
        isAnswered = false;
        document.getElementById('currentScore').textContent = score;
        document.getElementById('progressFill').style.width = ((currentQuestion)/quizData.length)*100 + "%";
        document.getElementById('progressText').textContent = `Question ${currentQuestion+1} of ${quizData.length}`;
        document.getElementById('questionText').textContent = q.question;

        const container = document.getElementById('optionsContainer');
        container.innerHTML = "";
        q.options.forEach((text, idx) => {
            const div = document.createElement('div');
            div.className = "option";
            div.textContent = text;
            div.onclick = () => selectAnswer(idx, div);
            container.appendChild(div);
        });
    }

    function selectAnswer(index, el){
        if(isAnswered) return;
        isAnswered = true;

        setTimeout(() => checkAnswer(index), 400);
    }

    function checkAnswer(selectedIndex){
        const q = quizData[currentQuestion];
        document.querySelectorAll('.option').forEach((opt, idx) => {
            if(idx === q.correct){
                opt.classList.add('correct');
                if(selectedIndex === idx) score++;
            } else if(idx === selectedIndex){
                opt.classList.add('incorrect');
            }
        });

        setTimeout(nextQuestion, 1400);
    }

    function nextQuestion(){
        clearInterval(timerInterval);
        currentQuestion++;
        if(currentQuestion < quizData.length){
            displayQuestion();
            startTimer();
        } else showResults();
    }

    function startTimer(){
        timer = 15;
        const t = document.getElementById('timer');
        t.textContent = timer;
        t.className = "timer";

        timerInterval = setInterval(() => {
            timer--;
            t.textContent = timer;
            if(timer <= 5) t.className = "timer danger";
            else if(timer <= 10) t.className = "timer warning";

            if(timer <= 0){
                clearInterval(timerInterval);
                checkAnswer(-1);
            }
        },1000);
    }

    function showResults(){
        document.getElementById('finalScore').textContent = `${score}/${quizData.length}`;
        const pct = Math.round((score/quizData.length)*100);
        const msg = pct>=90 ? `Outstanding, ${username}!`
                 : pct>=70 ? `Great job, ${username}!`
                 : pct>=50 ? `Good effort, ${username}!`
                 : `Don't give up, ${username}! Try again!`;
        document.getElementById('scoreMessage').textContent = msg;
        showScreen('resultsScreen');
    }

    function shareToX(){
        const pct = Math.round((score/quizData.length)*100);
        const text = `I scored ${score}/${quizData.length} (${pct}%) on the Ritual Quiz Challenge! Can you beat me?`;
        const url = "https://elite-quiz.bytrizz.com";
        window.open(`https://twitter.com/intent/tweet?text=${encodeURIComponent(text)}&url=${encodeURIComponent(url)}`);
    }
</script>
</body>
</html>
